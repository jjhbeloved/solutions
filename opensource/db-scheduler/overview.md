# db-scheduler overview

## 1. 核心架构设计

- **调度器（Scheduler）**：整个框架的核心组件，管理和执行任务
- **任务（Task）**：定义要执行的工作单元，包括RecurringTask和OneTimeTask等
- **执行器（Execution）**：表示任务的单次执行实例
- **调度客户端（SchedulerClient）**：提供对调度器的操作接口
- **执行处理器（ExecutionHandler）**：处理任务执行的结果和后续操作

## 2. 任务类型设计

- **RecurringTask**：周期性执行的任务，有固定的执行计划
- **OneTimeTask**：只执行一次的任务
- **CustomTask**：可完全自定义行为的任务类型
- **任务数据（TaskData）**：任务执行时可携带的数据

## 3. 调度策略

- **Schedule**：任务执行计划的抽象
- **FixedDelay**：固定间隔调度策略
- **Cron表达式**：基于cron表达式的调度策略
- **Daily/Weekly**：基于日、周的调度策略
- **自定义Schedule**：可实现自定义的调度计划

## 4. 持久化机制

- **数据库存储**：使用单表模型存储所有执行信息
- **表结构设计**：如何设计执行表以支持集群和监控
- **乐观锁机制**：如何避免任务重复执行
- **数据库方言**：支持不同数据库的特性

## 5. 轮询策略

- **轮询间隔**：如何配置最佳轮询间隔
- **fetch-and-lock-on-execute**：原始的轮询策略
- **lock-and-fetch**：基于SKIP LOCKED的优化轮询策略
- **性能对比**：不同轮询策略的性能特点

## 6. 集群支持

- **多实例协调**：如何在多节点环境下协调工作
- **心跳机制**：监测执行实例活跃状态
- **死亡执行处理**：如何处理由于节点故障导致的"死亡"执行
- **竞争策略**：多个实例如何公平竞争任务

## 7. 错误处理与恢复机制

- **执行失败处理**：任务执行失败时的处理流程
- **失败重试策略**：如何配置失败任务的重试机制
- **最大失败次数**：达到最大失败次数后的处理
- **人工干预**：如何人工干预失败的任务

## 8. 监控与管理

- **统计指标**：提供的执行统计和监控指标
- **执行历史**：如何查看和分析执行历史
- **运行时操作**：如何在运行时管理任务
- **健康检查**：如何验证调度器健康状态

## 9. 性能优化设计

- **批处理机制**：批量处理任务提高性能
- **轮询优化**：减少数据库负载的策略
- **执行线程池**：如何配置和调优执行线程池
- **高吞吐量配置**：处理高吞吐量场景的最佳实践

## 10. 与其他框架的集成

- **Spring Boot集成**：通过Spring Boot Starter快速集成
- **依赖注入支持**：如何在任务中使用依赖注入
- **与事务管理的集成**：如何使任务调度参与事务

## 11. 任务与执行

db-scheduler 将 Task（任务定义）和 Execution（执行实例）分开：

- 提高了集群环境下的任务管理能力
- 支持死亡执行检测和恢复
- 简化了任务状态跟踪

### 11.1 区别

#### **Task（任务）**

- **定义**：Task 定义了要执行的业务逻辑和调度信息
- **实现**：实现 `Task` 接口并定义 `execute(TaskInstance, ExecutionContext)` 方法
- **职责**：描述任务的"内容"和"执行后的处理逻辑"

#### **Execution（执行）**

- **定义**：表示单个任务执行的实例和状态
- **特点**：包含执行ID、执行时间、picked状态等信息
- **职责**：追踪任务执行的状态和结果

### 11.2 好处

#### **集群协调**

- 通过数据库锁定机制确保每个任务只被一个调度器实例执行
- 支持心跳机制，检测和处理因节点故障导致的"死亡"执行

#### **简洁的数据模型**

- 使用单表存储所有执行信息，减少数据库复杂度
- 简化了部署和维护成本

#### **灵活的执行处理**

- 可以根据执行结果决定是删除、重新调度或标记任务
- 支持自定义执行完成后的处理逻辑

## 12. 特色功能

### 12.1 单表设计

db-scheduler 使用单表设计存储所有执行信息：

#### 优点

1. **简化部署**：只需要管理一张表，减少数据库结构复杂度
2. **提高性能**：单表操作减少了JOIN开销，提高了查询效率
3. **易于维护**：便于备份、监控和故障排查
4. **适合高吞吐量**：简单的数据模型使其在高负载下表现良好

### 12.2 心跳机制

通过定期更新执行记录的心跳时间戳，实现对执行状态的监控：

1. **死亡执行检测**：自动检测没有更新心跳的"死亡"执行
2. **自动恢复**：可配置死亡执行的处理策略（重新调度或标记失败）
3. **提高可靠性**：即使在节点故障情况下也能保证任务最终被执行

## 13. 实际应用场景

### 13.1 适用场景

- **批处理作业**：定期数据处理、报表生成等批处理任务
- **分布式系统**：需要在多节点协调执行任务的分布式应用
- **高可靠要求**：对任务执行可靠性有高要求的业务场景
- **简化部署**：希望避免额外组件（如专用的消息队列）的环境

### 13.2 优势对比

- 相比 Quartz：更简单的数据库模型（1张表 vs 11张表）
- 相比消息队列：无需额外部署组件，直接利用现有数据库
- 相比内存调度器：提供持久化和集群支持，增强可靠性
