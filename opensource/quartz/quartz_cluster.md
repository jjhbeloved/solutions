# Quartz 集群模式的工作原理与恢复机制分析

Quartz 的恢复机制不仅仅是为了处理正常关闭过程中的再处理，它主要是为了处理各种非正常终止场景，确保系统的可用性和一致性。

它是一种权衡的结果：在分布式系统中，无法同时完美保证可用性、一致性和分区容忍性（CAP 定理）。**Quartz 选择了优先保证可用性**，同时**尽可能维持一致性**，这意味着在某些边缘情况下**可能会出现重复执行**等问题

> 一种尝试在节点非正常终止情况下维持系统一致性和可用性的机制，它优先考虑的是可用性而非绝对的一致性。

## 集群模式的本质

> Quartz 的集群模式是一种有状态的分布式调度模式，而不是单纯的无状态模式

Quartz 的集群模式是一种**有状态的分布式调度架构**，**每个节点都运行完整的 Scheduler 实例**，通过共享数据库实现协调。当检测到节点失效时，需要主动恢复错过的调度，这是因为：

1. 状态连续性：失效节点获取的触发器需要被释放
2. 作业可靠性：中断的作业需要根据其特性被正确处理
3. 错过触发策略：需要应用触发器的错过触发策略
4. 数据一致性：需要确保数据库状态与实际情况一致

### 架构特点

[时序图](./docs/quartz_recover.puml)

1. 共享数据库：**所有 Quartz 实例共享同一个数据库**，用于存储作业、触发器和调度器状态
2. 独立运行的调度器：**每个节点上都运行完整的 Scheduler 实例**
3. 状态同步：通过数据库实现状态同步和协调
   1. `并发问题`通过`竞争数据库锁`来解决
4. 负载分担：多个节点共同分担调度负载
   1. 没有内置的动态负载均衡机制，它采用的是**"先到先得"**的触发器获取策略
5. 故障转移：当一个节点失效时，其他节点可以接管其任务

### 不是单纯的主从模式

1. 没有专门的主节点负责调度
2. **所有节点都是对等的**，都可以触发和执行作业
3. 通过`数据库锁机制`**避免同一任务被多个节点同时执行**

### 不是完全无状态的

虽然作业数据存储在共享数据库中，但每个 Scheduler 实例在运行时维护着自己的状态：

- 已获取但尚未触发的触发器
- 正在执行的作业
- 本地缓存的作业和触发器信息

## 为什么需要主动恢复错过的调度

### 状态连续性保证

1. 失效节点可能已经获取了触发器但尚未执行
2. 这些触发器处于 ACQUIRED 状态，其他节点不会触发它们
3. 如果不主动恢复，这些触发器将永远处于 ACQUIRED 状态，导致任务无法执行

### 作业执行的可靠性

1. 失效节点可能正在执行某些作业
2. 这些作业可能只完成了一部分就被中断
3. 需要根据作业的特性（是否允许并发执行）决定如何处理

### 错过触发策略的应用 misfired

1. 由于节点失效，某些触发器可能已经错过了它们的触发时间
2. 每个触发器都有自己的错过触发策略（如立即触发、忽略等）
3. 需要应用这些策略以确保业务逻辑的正确性

### 数据一致性维护

1. 数据库中的状态必须与实际情况保持一致
2. 失效节点留下的状态记录需要被正确更新
3. 否则会导致系统状态不一致，影响后续调度

## 并发问题

1. 触发器执行分配：采用竞争机制，无预分配，通过乐观锁确保一个触发器只被一个节点获取
2. 并发问题解决：通过唯一 ID、状态记录、并发控制注解、特殊恢复处理和事务保证等机制防止并发问题

### 重复执行风险

> 是否存在重复执行呢？ A 不更新状态了，但是在执行job，执行后的状态无法更新到db 。B 不知道 job在执行，导致B重做了

对于标记了`@DisallowConcurrentExecution`的作业，这是一个特别需要关注的问题
风险减轻措施：

1. Quartz提供了作业执行上下文、事务管理等机制
2. 但这些机制无法完全消除分布式系统中的**重复执行风险**

### 实际解决方案

- 作业设计层面：幂等性设计、分布式锁
- 系统配置层面：增加心跳超时阈值、提高网络可靠性
- 架构层面：引入外部协调者、使用消息队列
- 在分布式系统中，完全避免重复执行是很困难的，最佳实践是设计能够处理重复执行的系统，而不是试图完全避免重复执行。

## 数据库表结构

``` sql
CREATE TABLE QRTZ_SCHEDULER_STATE (
  SCHED_NAME VARCHAR(120) NOT NULL,
  INSTANCE_NAME VARCHAR(200) NOT NULL,
  LAST_CHECKIN_TIME BIGINT NOT NULL,
  CHECKIN_INTERVAL BIGINT NOT NULL,
  PRIMARY KEY (SCHED_NAME, INSTANCE_NAME)
);
```

``` sql
CREATE TABLE QRTZ_LOCKS (
  SCHED_NAME VARCHAR(120) NOT NULL,
  LOCK_NAME VARCHAR(40) NOT NULL,
  PRIMARY KEY (SCHED_NAME, LOCK_NAME)
);
```

``` sql
CREATE TABLE QRTZ_FIRED_TRIGGERS (
  SCHED_NAME VARCHAR(120) NOT NULL,
  ENTRY_ID VARCHAR(95) NOT NULL,
  TRIGGER_NAME VARCHAR(200) NOT NULL,
  TRIGGER_GROUP VARCHAR(200) NOT NULL,
  INSTANCE_NAME VARCHAR(200) NOT NULL,
  FIRED_TIME BIGINT NOT NULL,
  SCHED_TIME BIGINT NOT NULL,
  STATE VARCHAR(16) NOT NULL,
  JOB_NAME VARCHAR(200) NULL,
  JOB_GROUP VARCHAR(200) NULL,
  IS_NONCONCURRENT VARCHAR(1) NULL,
  REQUESTS_RECOVERY VARCHAR(1) NULL,
  PRIMARY KEY (SCHED_NAME, ENTRY_ID)
);
```

## scheduler & job & trigger 如何实现负载均衡

### 作业执行基于触发器获取

1. 作业不是直接分配给特定机器的
2. 哪个**调度器**实例获取了**触发器**，对应的作业就在哪个机器上执行
3. 不同的触发器可能被不同的调度器实例获取，导致不同的作业在不同的机器上执行

### 负载分布机制

1. 基于**触发器**获取竞争
2. 遵循先到先得原则
3. 支持批量获取优化

### 一个 Job 在所有机器上运行

Quartz 的核心设计理念是一个 trigger 只能被`一个 scheduler` 实例获取和执行，不存在原生的"所有机器都执行"的触发器类型。
