# 跳表(SkipList)数据结构详解

## 目录
- [跳表(SkipList)数据结构详解](#跳表skiplist数据结构详解)
  - [目录](#目录)
  - [一、跳表基本概念](#一跳表基本概念)
    - [1.1 什么是跳表](#11-什么是跳表)
    - [1.2 跳表的基本结构](#12-跳表的基本结构)
  - [二、跳表的优缺点](#二跳表的优缺点)
    - [2.1 优点](#21-优点)
    - [2.2 缺点](#22-缺点)
  - [三、跳表的适用场景](#三跳表的适用场景)
    - [3.1 典型应用场景](#31-典型应用场景)
    - [3.2 著名系统中的应用](#32-著名系统中的应用)
  - [四、跳表的实现](#四跳表的实现)
    - [4.1 节点结构](#41-节点结构)
      - ["forward"命名的由来](#forward命名的由来)
    - [4.2 随机层数生成](#42-随机层数生成)
    - [4.3 核心操作](#43-核心操作)
    - [为什么需要确定每层的插入位置？](#为什么需要确定每层的插入位置)
    - [前驱节点更新的效率和机制？](#前驱节点更新的效率和机制)
  - [五、RocksDB中的跳表实现](#五rocksdb中的跳表实现)
    - [5.1 MemTable与通用跳表的区别](#51-memtable与通用跳表的区别)
    - [5.2 RocksDB跳表的优化策略](#52-rocksdb跳表的优化策略)
  - [参考资料](#参考资料)

## 一、跳表基本概念

### 1.1 什么是跳表

跳表(SkipList)是一种随机化的数据结构，基于并联的链表，其效率可比拟于平衡树（如红黑树），但实现起来更为简单。跳表在1989年由William Pugh提出，是对有序链表的一种优化升级版本。

跳表的核心思想是通过维护一系列层次化的链表，并在每一层中跳过部分节点，从而加快查找速度。其时间复杂度和空间复杂度分别为：
- 查找：平均O(log n)，最坏O(n)
- 插入：平均O(log n)，最坏O(n)
- 删除：平均O(log n)，最坏O(n)
- 空间复杂度：O(n)

### 1.2 跳表的基本结构

跳表由多层链表组成，每层都是一个有序链表。底层(Level 0)包含所有元素，而上层链表则包含部分元素，越往上包含的元素越少，形成了一种"跳跃"的索引结构。

```
Level 3: Head --------------------------------------------------------> Tail
                                                                |
Level 2: Head --------------------------> Node ----------------> Node ---> Tail
                                           |                     |
Level 1: Head ----------> Node ----------> Node --------> Node -> Node ---> Tail
                           |               |              |       |
Level 0: Head -> Node -> Node -> Node -> Node -> Node -> Node -> Node -> Tail
          |      |       |       |       |       |       |       |       |
         NIL    10      20      30      40      50      60      70     NIL
```

**重要说明**：上图中的垂直连接线表示同一个节点在不同层级上的存在，而不是指向下层节点的指针。每个实际节点可能存在于多个层级中，但节点之间的连接（水平箭头）仅在同一层级内。

例如，值为40的节点存在于Level 0、Level 1和Level 2三个层级，但它在每个层级上只有一个指向右侧下一节点的指针：
- 在Level 0上，它指向值为50的节点
- 在Level 1上，它指向值为60的节点
- 在Level 2上，它指向值为70的节点

下面是跳表的UML类图：

```
+---------------------+            +----------------------+
|     SkipList        |            |    SkipListNode      |
+---------------------+            +----------------------+
| - head: SkipListNode|<>--------->| - key: KeyType       |
| - tail: SkipListNode|            | - value: ValueType   |
| - maxLevel: int     |            | - level: int         |
| - size: int         |            | - forward: Node*[]   |
+---------------------+            +----------------------+
| + insert(k,v): bool |            |                      |
| + search(k): v      |            |                      |
| + remove(k): bool   |            |                      |
| + size(): int       |            |                      |
+---------------------+            +----------------------+
```

具体来说，跳表具有以下特点：
1. 每个节点都包含一个键值对和多个指向后继节点的指针
2. 节点的层数（即指针数量）是随机生成的
3. 在每一层，节点按键的升序排列
4. 查找时从最高层开始，逐层降低

## 二、跳表的优缺点

### 2.1 优点

1. **实现简单**：相比于平衡树（如红黑树、AVL树），跳表的实现逻辑更加简单直观
2. **高效的查找性能**：平均查找时间复杂度为O(log n)
3. **支持顺序访问**：作为一个有序链表，跳表天然支持范围查询和顺序遍历
4. **易于并行化**：跳表的结构允许多个操作在不同部分同时进行，更易于实现无锁并发
5. **动态数据结构**：可以高效地插入、删除元素，而不需要像某些平衡树那样进行复杂的平衡操作
6. **内存分配友好**：不需要像树那样预先分配或重新平衡节点，内存利用更灵活
7. **概率平衡**：通过随机化技术自然地保持平衡，不需要复杂的重平衡操作

### 2.2 缺点

1. **存储开销较大**：跳表需要存储额外的指针，空间消耗比普通有序链表大
2. **随机性**：由于层高是随机生成的，最坏情况下的性能无法保证（虽然这种情况极少发生）
3. **缓存不友好**：相比于数组或某些紧凑的树结构，跳表的节点分散在内存中，可能导致较多的缓存未命中
4. **复杂度常数较大**：虽然渐近复杂度与平衡树相同，但常数因子通常更大
5. **不适合密集型只读场景**：如果几乎不修改数据，可能有其他更适合的数据结构

## 三、跳表的适用场景

### 3.1 典型应用场景

跳表特别适合以下应用场景：

1. **需要高效的动态有序集合**：需要频繁插入、删除，同时又需要保持元素有序
2. **范围查询频繁**：需要查找某个范围内的所有元素
3. **多线程环境**：需要在并发环境下高效操作有序数据
4. **内存数据库或缓存**：需要快速访问且经常变化的有序数据集
5. **对实现简单性有要求**：比如资源受限的环境或需要易于维护的场景

### 3.2 著名系统中的应用

许多知名系统都使用了跳表数据结构：

1. **Redis**：在有序集合(Sorted Set)的实现中使用跳表
2. **LevelDB/RocksDB**：在内存表(MemTable)组件中使用跳表存储最近写入的数据
3. **Lucene**：在倒排索引的某些实现中使用跳表优化查询
4. **ConcurrentSkipListMap/Set**：Java并发集合框架中的跳表实现
5. **InfluxDB**：时序数据库中使用跳表管理时间序列数据

## 四、跳表的实现

### 4.1 节点结构

一个典型的跳表节点包含：

```c++
struct SkipListNode {
    // 节点存储的键值
    KeyType key;
    ValueType value;
    
    // 当前节点的层数
    int level;
    
    // 指向各层的下一个节点的指针数组
    SkipListNode* forward[MAX_LEVEL];
};
```

#### "forward"命名的由来

跳表实现中使用"forward"而非"next"来命名指向下一节点的指针数组，这有几个原因：

1. **历史渊源**：William Pugh在原始跳表论文中使用了这个命名，大多数实现都沿用了这一传统
2. **多层指针表示**：表示这是一个指针数组，其中`forward[i]`明确表示"在第i层向前的指针"
3. **方向明确性**：强调了指针的前进方向，与跳表的搜索方向一致
4. **语义准确性**：在跳表中，节点在不同层级有不同的"前进"目标，比单一的"next"更能表达这种结构

需要注意的是，每个节点在每一层只有一个forward指针，指向该层的下一个节点。不同层级的forward指针可能指向不同的节点，这正是跳表"跳跃"特性的关键。

### 4.2 随机层数生成

跳表的效率很大程度上依赖于层数的随机分布。常用的是几何分布：

```c++
int randomLevel() {
    int level = 1;
    // p = 0.25或0.5是常见的选择
    while (random() < p && level < MAX_LEVEL) {
        level++;
    }
    return level;
}
```

这确保了约有1/p的节点有第1层指针，1/p²的节点有第2层指针，依此类推。这种分布使得跳表近似平衡。

**随机层数的原理和重要性**：

1. **概率平衡**：
   - 随机层数是跳表实现"概率平衡"的关键
   - 使用几何分布：每个节点有1/p的概率被提升到Level 1，1/p²概率到Level 2，依此类推
   - 这种分布确保了跳表近似平衡，层数越高的节点越少

2. **自适应性**：
   - 随机决定使得跳表能够自适应数据分布
   - 无需像平衡树那样复杂的重平衡操作
   - 插入操作简单高效，不会因为调整平衡而增加复杂度

3. **理论基础**：
   - 随机层数使得搜索路径的期望长度为O(log n)
   - 如果层数固定或按规则确定，可能导致最坏情况性能下降
   - 随机化是跳表与其他有序数据结构的关键区别


### 4.3 核心操作

**1. 查找操作**

查找从最高层开始，如果当前节点的下一个节点的键值小于目标值，就前进到该节点，否则降到下一层继续查找。

下面是查找操作的序列图和详细步骤说明：

```
+--------+          +--------+          +--------+          +--------+
| Client |          | SkipList|          | CurrentNode |    | ForwardNode |
+--------+          +--------+          +-------------+    +-------------+
     |                   |                   |                   |
     | search(key=45)    |                   |                   |
     |------------------>|                   |                   |
     |                   |                   |                   |
     |                   | 从最高层(L3)开始 |                   |
     |                   |------------------>|                   |
     |                   |                   |                   |
     |                   |                   | 检查forward[3]  |
     |                   |                   |------------------>|
     |                   |                   |                   | key=70 > 45
     |                   |                   |<------------------|
     |                   |                   | 降到L2,保持当前节点|
     |                   |                   |------------------>|
     |                   |                   | 检查forward[2]  |
     |                   |                   |------------------>|
     |                   |                   |                   | key=60 > 45
     |                   |                   |<------------------|
     |                   |                   | 继续降层并检查   |
     |                   |<------------------|                   |
     |                   | 返回结果        |                   |
     |<------------------|                   |                   |
     |                   |                   |                   |
```

**查找算法详细步骤（以查找键值45为例）**：

1. **初始化**：从跳表的头节点(Head)开始，设置当前节点为头节点，当前层级为最高层（例如Level 3）
   
2. **在当前层级查找**：
   - 检查当前节点在该层级的forward指针指向的节点（即current.forward[level]）
   - 如果forward节点的key小于目标值45，则向前移动：current = current.forward[level]
   - 如果forward节点的key大于等于目标值45，则不前进，转到步骤3

3. **降层操作**：
   - 当发现current.forward[level]的key大于等于目标值45时，current节点保持不变
   - 只降低当前层级(level--)，不改变当前节点
   - 然后回到步骤2，在新的层级继续查找
   
4. **重复过程**：
   - 在每个层级，尝试向前移动，直到不能前进
   - 降层后，从当前节点开始在新层级查找，不回到头节点
   - 每次降层时，视野变得更"精细"，可以看到更多的节点

5. **底层处理**：
   - 当到达最底层(Level 0)时，执行最后一次前进检查
   - 如果找到key等于45的节点，则返回该节点
   - 如果最终位置的下一个节点key大于45，则表示目标值不存在

**降层示例**：
- 假设当前在Level 3，当前节点是Head，它的forward[3]指向key=70的节点
- 因为70 > 45，所以不前进，降到Level 2，当前节点仍然是Head
- 在Level 2，检查Head.forward[2]，如果也大于45，则继续降到Level 1
- 当在某一层找到forward节点的key小于45时，才向前移动当前节点

跳表查找的核心优势在于：通过在高层级进行"长距离跳跃"，跳过许多节点，然后在需要时降低层级进行更精细的查找，从而将链表O(n)的查找效率提升到平均O(log n)。

**2. 插入操作**

插入时先确定新节点的随机层数，然后从最高层开始查找插入位置，并在每一层上调整指针。

下面是插入操作的序列图和详细步骤说明：

```
+--------+          +--------+          +--------+          +--------+
| Client |          | SkipList|          | 前驱数组 |          | 新节点 |
+--------+          +--------+          +--------+          +--------+
     |                   |                   |                   |
     | insert(key=45,v)  |                   |                   |
     |------------------>|                   |                   |
     |                   |                   |                   |
     |                   | 1.随机生成层数(level=2) |              |
     |                   |------------------->|                  |
     |                   |                   |                   |
     |                   | 2.查找各层插入位置 |                   |
     |                   | (类似于查找过程)  |                   |
     |                   |------------------>|                   |
     |                   |                   | update[0]=节点30  |
     |                   |                   | update[1]=节点40  |
     |                   |                   | update[2]=Head节点 |
     |                   |                   |                   |
     |                   | 3.创建新节点      |                   |
     |                   |---------------------------------------->|
     |                   |                   |                   | key=45,level=2
     |                   |                   |                   |
     |                   | 4.更新前驱节点的指针 |                 |
     |                   |------------------>|                   |
     |                   |                   |------------------>|
     |                   |                   | update[0].forward[0]=新节点 |
     |                   |                   | update[1].forward[1]=新节点 |
     |                   |                   | update[2].forward[2]=新节点 |
     |                   |                   |                   |
     |                   | 5.设置新节点的forward指针 |            |
     |                   |---------------------------------------->|
     |                   |                   |                   |
     |                   |<------------------|                   |
     |                   | 插入完成          |                   |
     |<------------------|                   |                   |
     |                   |                   |                   |
```

**插入算法详细步骤（以插入键值45为例）**：

1. **随机生成层数**：
   - 使用随机函数决定新节点的层数(level)，例如这里随机得到level=2
   - 层数决定了新节点将出现在哪些层级中（从Level 0到Level level）

2. **查找各层插入位置**：
   - 类似于查找操作，从最高层开始向下查找
   - 关键不同点：维护一个前驱数组update[0...maxLevel]
   - 在每一层降级前，记录当前节点到update数组中（这个节点将成为新节点在该层的前驱）
   - 最终update[i]存储的是新节点在第i层的前驱节点

3. **创建新节点**：
   - 分配内存创建新节点，设置键值对和层数
   - 初始化forward指针数组（暂时为空或指向尾节点）

4. **更新前驱节点的指针**：
   - 对每一层i（从0到level-1）
   - 设置update[i].forward[i]=新节点
   - 这步操作将新节点"插入"到链表中

5. **设置新节点的forward指针**：
   - 对每一层i（从0到level-1）
   - 设置新节点.forward[i]=update[i].forward[i]（即新节点指向原来前驱指向的节点）
   - 完成链接关系

**关于update数组和插入位置的重要说明**：

1. **update数组的本质**：
   - update数组**不是**跳表数据结构的一部分，而是插入操作中的临时辅助数组
   - 它只存在于插入或删除操作过程中，不会持久保存
   - 每次插入操作都会创建一个新的update数组，用完即销毁
   - 跳表本身并不是双向链表，没有反向指针

2. **插入位置的确定**：
   - 插入位置的确定基于键值的大小顺序，遵循严格的有序性
   - 新节点必须插入到键值小于它的节点之后，键值大于它的节点之前
   - 例如节点45必须插入到节点30之后，节点50之前
   - 如果存在相同键值的节点，可以根据实现策略决定插入位置（前、后或替换）

3. **链接过程的实质**：
   - 文档中描述的"双向链接"不是指建立双向链表，而是指两个方向的指针调整：
     1. 前驱节点指向新节点：`update[i].forward[i] = newNode`
     2. 新节点指向后继节点：`newNode.forward[i] = originalNext`
   - 这两步确保新节点正确插入到链表中，维持链表的完整性
   - 插入完成后，跳表仍然是单向链表结构，只有forward指针

4. **查找插入位置的精确过程**：
   - 从最高层开始，向右移动直到找到大于等于目标键的节点，或到达链表尾部
   - 记录当前位置到update数组
   - 降层继续查找
   - 在每层重复这个过程
   - 最终在Level 0层找到的位置就是新节点应该插入的位置

### 为什么需要确定每层的插入位置？

**每层独立确定插入位置的必要性**：

1. **层级独立性**：
   - 跳表的每一层是独立的有序链表
   - 新节点在每一层的位置可能有不同的前驱节点
   - 必须在每层找到正确的插入位置以维持有序性

2. **前驱节点不同**：
   - 例如插入值45的节点时：
     - 在Level 0可能位于值为30和50之间
     - 在Level 1可能位于值为40和60之间
     - 在Level 2可能直接连接到头节点和某个高层节点之间
   - 不同层级的间隔和节点分布不同

3. **数据结构完整性**：
   - 必须更新所有受影响层级的链接关系
   - 确保每一层的链表仍然完整且有序
   - 保持跳表的搜索特性不受破坏

### 前驱节点更新的效率和机制？

**前驱节点更新机制和效率分析**：

1. **update数组机制**：
   - 查找过程中维护update数组，记录每层的前驱节点
   - 这避免了插入时重新搜索的开销
   - update[i]存储的是新节点在第i层的前驱节点引用

2. **一次查找多次利用**：
   - 初始查找过程中就已确定所有层的前驱节点
   - 插入时只需O(L)时间更新这些前驱（L为新节点的层数）
   - 平均而言L远小于节点总数n，为O(1)

3. **原子更新**：
   - 在并发环境中，可以通过原子CAS操作更新前驱节点的指针
   - 这是跳表在并发场景中性能优异的原因之一
   - 不同层的更新可以分离处理，降低锁竞争

4. **两个更新方向**：
   - 前驱节点指向新节点：update[i].forward[i] = newNode
   - 新节点指向后继节点：newNode.forward[i] = update[i].forward[i]
   - 这两步操作确保链表的完整性

5. **并发环境中的锁竞争管理**：
   - **不同层级的锁策略**：
     - 不同层级可以使用独立的锁，因为每层是逻辑独立的链表
     - 当多个线程操作不同层级时，不会相互阻塞
     - 例如：线程A更新节点在Level 2的链接，同时线程B可以更新同一节点在Level 0的链接
   
   - **同层级的锁策略**：
     - 同一层级的更新必须串行化以保证数据一致性
     - 常见的处理方法包括：
       1. **细粒度锁**：为链表的每个节点或区域分配独立的锁
       2. **手递手锁定（Hand-over-hand locking）**：在遍历链表时，先锁定当前节点，再锁定下一节点，然后释放前一节点的锁
       3. **乐观锁**：使用版本号或时间戳来检测冲突，只有在提交时才验证冲突
       4. **无锁实现**：通过原子CAS操作实现无锁并发，如Java的ConcurrentSkipListMap
     
   - **实际实现示例**：
     - **Java ConcurrentSkipListMap**：完全无锁实现，依赖原子CAS操作
     - **Redis的跳表**：所有操作由单线程执行，不需要并发控制
     - **LevelDB/RocksDB**：使用粗粒度锁保护整个MemTable

   - **无锁跳表的关键技术**：
     - 先构造新节点，设置其所有forward指针
     - 使用原子CAS操作更新前驱节点的forward指针
     - 对冲突采用重试机制而非阻塞
     - 处理ABA问题（使用标记指针或版本号）
     - 内存回收问题的处理（通常需要垃圾回收或引用计数）

6. **跨层更新的原子性问题**：
   - **跨层更新挑战**：
     - 插入和删除操作通常需要更新多个层级的前驱节点指针
     - 如果这些更新不是原子的，可能导致中间状态被其他线程观察到，造成数据结构不一致
   
   - **CAS解决方案**：
     - **逐层CAS更新**：最常见的方法是从底层开始，逐层使用CAS操作更新前驱节点的指针
     - **失败处理**：如果任何一层的CAS操作失败，则回滚已完成的更新或重试整个操作
     - **节点可见性控制**：确保新节点的所有forward指针都设置好后，才开始更新前驱节点指针

   - **实现策略**：
     - **自底向上法**：先更新底层(Level 0)，再逐层向上更新，这样即使高层更新失败，底层链表仍然正确
     - **帮助协议**：当一个线程发现另一个线程正在进行插入但未完成时，可以帮助完成该操作
     - **标记指针**：使用指针的低位比特标记节点状态（如"正在删除"状态），防止中间状态的节点被错误修改

   - **Java ConcurrentSkipListMap的实现**：
     - 使用自底向上的CAS更新策略
     - 先完成新节点的构建和前驱节点查找
     - 从Level 0开始使用CAS更新前驱节点指针
     - 如果失败则重试，而不是使用锁等待
     - 通过标记被删除节点防止并发修改

   - **原子性与一致性保证**：
     - CAS确保每个指针更新都是原子的
     - 自底向上的策略确保即使部分失败，数据结构也能保持一致性
     - 底层总是包含完整数据，高层仅作为索引，可以容忍短暂的不一致

跳表插入操作的总体复杂度为O(log n)，其中包括：查找合适位置O(log n)和更新指针O(L)，由于平均L=O(1)，因此总体仍为O(log n)。

**3. 删除操作**

从最高层开始查找目标节点，找到后在所有层中删除对该节点的引用。

下面是删除操作的序列图和详细步骤说明：

```
+--------+          +--------+          +--------+          +--------+
| Client |          | SkipList|          | 前驱数组 |          | 目标节点 |
+--------+          +--------+          +--------+          +--------+
     |                   |                   |                   |
     | remove(key=40)    |                   |                   |
     |------------------>|                   |                   |
     |                   |                   |                   |
     |                   | 1.查找目标节点和前驱 |                |
     |                   | (类似于查找过程)  |                   |
     |                   |------------------>|                   |
     |                   |                   |------------------>|
     |                   |                   |                   |
     |                   |                   | update[0]=节点30  |
     |                   |                   | update[1]=Head节点|
     |                   |                   | update[2]=Head节点|
     |                   |                   |                   |
     |                   | 2.更新前驱节点指针 |                  |
     |                   |------------------>|                   |
     |                   |                   | update[0].forward[0]=目标节点.forward[0] |
     |                   |                   | update[1].forward[1]=目标节点.forward[1] |
     |                   |                   | update[2].forward[2]=目标节点.forward[2] |
     |                   |                   |                   |
     |                   | 3.释放目标节点资源 |                  |
     |                   |---------------------------------------->|
     |                   |                   |                   | 节点被删除
     |                   |<------------------|                   |
     |                   | 删除完成         |                   |
     |<------------------|                   |                   |
     |                   |                   |                   |
```

**删除算法详细步骤（以删除键值40为例）**：

1. **查找目标节点和前驱**：
   - 类似于插入操作，从最高层开始向下查找
   - 维护一个前驱数组update[0...maxLevel]
   - 在每一层降级前，记录当前节点到update数组中
   - 这些节点是目标节点在各层的前驱节点
   - 在最底层(Level 0)确认目标节点存在

2. **更新前驱节点指针**：
   - 对于每一层i（从0到目标节点的最高层）
   - 设置update[i].forward[i] = targetNode.forward[i]
   - 这步操作使前驱节点直接指向目标节点的后继节点，绕过目标节点

3. **释放目标节点资源**：
   - 在所有前驱节点的指针更新完成后，释放目标节点占用的内存
   - 在某些实现中，可能会延迟回收节点资源以支持并发访问

**关于删除操作的重要说明**：

1. **并发删除的挑战**：
   - 在并发环境中，删除操作可能与其他操作（如插入、查询）同时进行
   - 必须确保删除过程中不会影响其他操作的正确性
   - 常见策略是使用"逻辑删除"和"物理删除"两步走

2. **逻辑删除与物理删除**：
   - **逻辑删除**：首先标记节点为"已删除"状态，但不立即从结构中移除
   - **物理删除**：稍后通过更新前驱节点的指针，将节点从结构中真正移除
   - 这种两阶段删除可以简化并发控制

3. **标记指针技术**：
   - 在一些无锁实现中，使用指针的低位比特标记节点状态
   - 例如，将forward指针的最低位设为1表示"节点正在删除中"
   - 其他线程看到标记后，会避免修改该节点或可能绕过它

4. **多层更新的原子性**：
   - 与插入类似，删除也需要更新多个层级的前驱指针
   - 通常采用自底向上的策略，先更新Level 0，再逐层向上
   - 即使高层更新失败，底层的链表结构仍然保持正确

5. **内存回收问题**：
   - 即使节点从跳表中物理删除，其他线程可能仍持有对它的引用
   - 解决方案包括：
     - 延迟回收(例如通过垃圾收集)
     - 使用引用计数
     - 使用危险指针(hazard pointer)或RCU(Read-Copy-Update)等技术

删除操作的总体复杂度与插入类似，为O(log n)，其中包括：查找目标节点O(log n)和更新前驱指针O(L)，其中L为目标节点的层数。

## 五、RocksDB中的跳表实现

RocksDB使用跳表作为其MemTable的默认实现，但其跳表实现有一些特别之处。

### 5.1 MemTable与通用跳表的区别

1. **键值对编码**：RocksDB的跳表不直接存储键值对，而是存储经过特殊编码的内部键(InternalKey)
2. **并发控制**：针对RocksDB的使用场景做了并发优化
3. **内存管理**：使用自定义的内存分配器以提高性能并减少内存碎片
4. **写入优化**：针对写入密集型工作负载进行了优化
5. **插入顺序感知**：通过序列号(sequence number)追踪插入顺序
6. **无删除操作**：MemTable的跳表不支持物理删除，而是通过标记删除的方式处理
7. **批量插入支持**：优化了批量写入的性能
8. **内部结构封装**：与通用跳表不同，MemTable的跳表实现高度封装和专用化

**RocksDB MemTable跳表的代码地址**：
- 跳表实现核心代码位于：[memtable/skiplist.h](https://github.com/facebook/rocksdb/blob/main/memtable/skiplist.h)
- MemTable的实现位于：[db/memtable.h](https://github.com/facebook/rocksdb/blob/main/db/memtable.h) 和 [db/memtable.cc](https://github.com/facebook/rocksdb/blob/main/db/memtable.cc)
- 跳表迭代器实现位于：[memtable/skiplist_iterator.h](https://github.com/facebook/rocksdb/blob/main/memtable/skiplist_iterator.h)

下面是通用跳表与RocksDB MemTable跳表的结构对比：

```
【通用跳表】
+-------------------+      +-------------------+      +-------------------+
| Node              |      | Node              |      | Node              |
|-------------------|      |-------------------|      |-------------------|
| key: "apple"      |      | key: "banana"     |      | key: "cherry"     |
| value: Value1     |----->| value: Value2     |----->| value: Value3     |
| level: 2          |      | level: 3          |      | level: 1          |
| forward[0,1,2]    |      | forward[0,1,2,3]  |      | forward[0,1]      |
+-------------------+      +-------------------+      +-------------------+

【RocksDB MemTable跳表】
+-------------------------+      +-------------------------+      +-------------------------+
| Node                    |      | Node                    |      | Node                    |
|-------------------------|      |-------------------------|      |-------------------------|
| internalKey:            |      | internalKey:            |      | internalKey:            |
|   userKey: "apple"      |      |   userKey: "banana"     |      |   userKey: "cherry"     |
|   seqNum: 7             |----->|   seqNum: 5             |----->|   seqNum: 9             |
|   type: kTypeValue      |      |   type: kTypeValue      |      |   type: kTypeDeletion   |
| encodedValue: Value1    |      | encodedValue: Value2    |      | encodedValue: (empty)   |
| level: 2                |      | level: 3                |      | level: 1                |
| arenaPtr: 0x12345       |      | arenaPtr: 0x67890       |      | arenaPtr: 0x24680       |
+-------------------------+      +-------------------------+      +-------------------------+
```

以上对比图展示了几个关键区别：
- RocksDB的跳表节点包含内部键(InternalKey)，由用户键、序列号和类型组成
- RocksDB支持通过标记删除(kTypeDeletion)而非物理删除
- RocksDB的节点分配在Arena内存池中，通过指针引用
- 序列号(seqNum)用于确保数据一致性和维护写入顺序

**InternalKey的优势与作用**：

1. **多版本并发控制(MVCC)**：
   - 通过序列号(sequence number)实现了数据的多版本并发控制
   - 每次写操作都分配一个递增的序列号，较大的序列号表示较新的版本
   - 读取时可以指定读取版本(sequence number)，实现时间点查询和快照读取

2. **逻辑删除支持**：
   - InternalKey中包含类型字段(type)，可标记为值(Value)或删除标记(Deletion)
   - 删除操作不需要物理删除节点，只需插入一个删除类型的记录
   - 减少了并发环境中物理删除的复杂性，提高了性能

3. **简化合并过程**：
   - 在LSM树的Compaction(合并)过程中，相同key的多个版本可以根据序列号合并
   - 删除标记可以在合并时清理掉旧版本数据，节省存储空间
   - 减少了合并时的冲突处理逻辑

4. **事务支持**：
   - 序列号和类型字段组合支持了RocksDB的事务功能
   - 写入和删除操作可以先缓存再提交，通过序列号控制可见性

5. **性能优化**：
   - InternalKey的设计允许键按字典序比较，简化了跳表的比较逻辑
   - 支持前缀压缩，减少内存使用并提高缓存效率
   - 编码格式经过优化，支持直接内存比较而无需解码

6. **兼容LSM树架构**：
   - InternalKey设计与LSM树架构紧密集成，支持MemTable到SST文件的无缝转换
   - 在整个存储引擎中保持一致的键表示，简化了代码逻辑

**多版本跳表存储案例：**

跳表在RocksDB中的一个重要应用是实现多版本并发控制(MVCC)，下面通过一个案例来说明这一机制：

```
【多版本跳表存储示意图】
+------------------------------------------------------------------+
|                          跳表结构                                 |
+------------------------------------------------------------------+
| Level 2: Head ---------------------------------> [apple,9,val] -> |
|                                                       |            |
| Level 1: Head ------------> [apple,5,val] ---------> [apple,9,val] -> |
|                              |                          |            |
| Level 0: Head -> [apple,2,del] -> [apple,5,val] -> [apple,9,val] -> |
+------------------------------------------------------------------+
                    |             |             |
                  UserKey       SeqNum        Type
                  ("apple")     (版本号)     (值类型)
```

**案例说明：**
假设对同一个键"apple"进行了以下操作序列：
1. SeqNum=2: 删除"apple"键（标记为删除）
2. SeqNum=5: 写入"apple"键，值为"value1" 
3. SeqNum=9: 更新"apple"键，值为"value2"

**多版本查询示例：**

1. **查询当前最新值** (snapshot=10 或不指定):
   - 从最高层开始，查找键"apple"
   - 找到 [apple,9,val]，返回"value2"
   - 时间复杂度：O(log n)，n为跳表节点数

2. **查询历史版本** (snapshot=7):
   - 从最高层开始，查找键"apple"
   - 找到 [apple,9,val]，但其SeqNum > 7，继续查找
   - 降到Level 1，找到 [apple,5,val]，其SeqNum ≤ 7
   - 返回"value1"
   - 即使数据已更新，仍能查询到历史版本

3. **查询更早版本** (snapshot=3):
   - 类似地，找到 [apple,2,del]
   - 因为是删除标记，返回"键不存在"

**实现要点：**

1. **复合键结构**：
   - 物理存储键 = 用户键 + 序列号 + 类型标记
   - 按物理键排序：先按用户键字典序，同用户键按序列号降序

2. **查询优化**：
   - 预先过滤：通过布隆过滤器快速判断键是否可能存在
   - 层级加速：利用跳表多层结构加速查找过程
   - 版本筛选：只返回序列号小于等于查询快照的最大版本

3. **写入优化**：
   - 新版本总是以更大的序列号写入
   - 不需要修改或删除旧版本数据
   - 写入操作不影响并发读取

通过这种设计，RocksDB跳表能够同时高效支持：
- 点查询：O(log n)时间复杂度
- 范围查询：连续遍历相邻节点
- 时间点查询：按照指定时间点（序列号）查询历史数据
- 并发访问：读操作完全无锁，写操作互不干扰

这种多版本机制使得RocksDB能在保证高性能的同时，提供一致性视图和隔离性保证，对实现数据库事务功能至关重要。

### 5.2 RocksDB跳表的优化策略

RocksDB对跳表实现了多项针对性优化，使其在LSM树架构中发挥最佳性能：

1. **自适应突变**：
   - **实现机制**：根据工作负载特征动态调整跳表参数，如最大层数和层提升概率
   - **优化原理**：不同工作负载(读密集或写密集)下，最优的跳表参数不同
   - **效果**：使跳表结构能适应变化的工作负载，平衡读写性能
   - **代码实现**：通过性能监控触发参数调整，如`p_`值的动态变更

2. **内存分配优化**：
   - **Arena内存池**：使用专门设计的Arena内存分配器管理所有节点
   - **优化原理**：减少内存碎片，避免频繁的小块内存分配和释放
   - **批量分配**：预先分配大块内存，然后在其中快速分配节点空间
   - **效果**：显著降低内存分配开销，提高缓存友好性
   - **代码示例**：
     ```cpp
     char* mem = arena->Allocate(sizeof(Node) + sizeof(void*) * (height - 1));
     return new (mem) Node(key, height);
     ```

3. **紧凑编码**：
   - **变长编码**：对序列号和类型使用变长编码技术
   - **前缀压缩**：相邻键的共同前缀只存储一次
   - **优化原理**：利用数据局部性减少存储空间
   - **效果**：减少内存使用30-50%，提高缓存命中率
   - **具体实现**：使用Varint编码和前缀压缩算法

4. **并发访问优化**：
   - **无锁设计**：读操作完全无锁，不阻塞写操作
   - **细粒度锁**：更新操作使用细粒度锁或无锁CAS操作
   - **优化原理**：最小化线程间的互斥和等待
   - **效果**：高并发环境下吞吐量接近线性扩展
   - **技术细节**：利用原子操作和RCU(Read-Copy-Update)技术

5. **局部性优化**：
   - **节点布局**：精心设计节点内存布局以提高缓存命中率
   - **预取策略**：实现智能预取，减少缓存未命中
   - **优化原理**：利用空间局部性和CPU缓存特性
   - **效果**：2-3倍的随机读性能提升
   - **技术实现**：节点内存对齐和数据结构重排

6. **内联小值**：
   - **实现机制**：小于特定阈值的值直接存储在节点中，而非单独分配
   - **优化原理**：减少指针间接访问，提高内存局部性
   - **效果**：小键值对的访问性能提升20-30%
   - **实现细节**：基于值大小的存储策略选择

7. **布隆过滤器集成**：
   - **实现机制**：在跳表查找前先检查布隆过滤器
   - **优化原理**：快速过滤不存在的键，避免昂贵的跳表搜索
   - **效果**：对于不存在的键查询性能提升数倍
   - **应用场景**：特别适合大量"键不存在"的查询场景

8. **批量操作优化**：
   - **实现机制**：特殊设计的批量写入和删除接口
   - **优化原理**：减少重复的搜索路径和锁操作
   - **效果**：批量操作比单个操作快3-5倍
   - **代码示例**：WriteGroup实现和批量提交

9. **特殊迭代器实现**：
   - **实现机制**：针对不同访问模式的专用迭代器
   - **优化原理**：针对顺序访问和范围查询进行优化
   - **效果**：迭代性能提升2倍以上
   - **迭代器类型**：包括前向迭代器、反向迭代器和跳跃迭代器

这些优化使RocksDB的跳表实现在保持基本跳表优势(实现简单、动态平衡)的同时，极大提升了性能，特别适合作为LSM树架构中的MemTable组件，高效处理写密集型工作负载。

## 参考资料

1. Pugh, William. "Skip lists: a probabilistic alternative to balanced trees." Communications of the ACM 33.6 (1990): 668-676.
2. Redis源码中的跳表实现: https://github.com/redis/redis/blob/unstable/src/t_zset.c
3. RocksDB官方文档: https://github.com/facebook/rocksdb/wiki/MemTable
4. Dean, Jeff, and Sanjay Ghemawat. "LevelDB: A Fast Persistent Key-Value Store." Google's Developer Blog (2011).
5. Herlihy, Maurice, et al. "A provably correct scalable concurrent skip list." Conference On Principles of Distributed Systems (OPODIS). 2006. 