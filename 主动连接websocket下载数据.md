# 主动连接 websocket 下载数据

## 需求

设计一个系统，收到 kafka 事件，事件里有一个websocket的地址，立即连接到这个地址去拉取数据，保存数据一天

1. 可能会有很多的kafka事件，要主动创建很多的websocket连接，一个进程能开辟多少个websocket连接
2. 重启进程后，断开的websocket 连接要重建连接。如何保证数据不丢失，或者不重复
3. 存储的数据比较多，但是只需要一天，存储方案怎么考虑
4. 随着连接数的增加，如何横向的扩容来解决负载的问题呢

## 技术方案(太粗了)

### 1. 处理大量 Kafka 事件和 WebSocket 连接

- 使用 Kafka 消费者组来处理事件，确保每个事件只被一个消费者处理。
- 使用异步编程（如 Node.js 或 Python 的 asyncio）来管理 WebSocket 连接。
- 一个进程能开辟的 WebSocket 连接数取决于系统资源和实现方式，通常可以达到数千个。

### 2. 重启进程后的连接重建和数据一致性

- 使用持久化存储（如 Redis）保存 WebSocket 连接状态和偏移量。
- 进程重启时，从 Redis 中读取连接状态并重建连接。
- 使用唯一消息 ID 或时间戳来确保数据不重复。

### 3. 数据存储方案

- 使用高效的时间序列数据库（如 InfluxDB 或 TimescaleDB）存储数据。
- 设置数据保留策略，只保留一天的数据，自动删除过期数据。

### 4. 横向扩容

- 使用容器化技术（如 Docker）和容器编排工具（如 Kubernetes）来管理和扩展服务。
- 根据连接数和负载，动态调整容器实例数量。
- 使用负载均衡器（如 Nginx 或 HAProxy）分发流量

## 技术重点(技术难点)

### 解决 Kafka 事件创建的 WebSocket sessions 数据不均衡问题

Kafka 消息的不均衡可能会导致 WebSocket 会话分布在处理线程或实例之间的负载不均。为解决此问题，可以采用以下方案：

#### Kafka 分区与消费者映射

- 确保 Kafka 分区与消费者实例 的分配均匀
- 使用 Kafka 的 Consumer Group 机制，每个实例只消费部分分区
- Kafka 会自动平衡分区到消费者的分配关系，尽量保证均匀分配
- 每个分区内的事件由对应消费者处理，避免跨实例处理导致的重复连接问题

#### 自定义分区策略

- 如果 WebSocket 地址具有一定的 hash 特性（例如 URL 中的特定字段），可以通过自定义分区策略，将相同特性的地址分配到同一分区
- 自定义分区逻辑：根据 WebSocket 地址计算 hash 值，分配到对应的 Kafka 分区
- 每个实例通过分区保证任务的均匀分配

#### 动态任务分配(*)

- 将 Kafka 事件处理逻辑与 WebSocket 管理解耦，使用一个 任务调度中心
- 任务调度中心根据实例负载动态分配 WebSocket 地址处理任务
- 如 Redis/Zookeeper 记录任务归属，避免重复创建 WebSocket

### 应用扩容：如何重新分配已有 WebSocket Sessions

当应用扩容时，需要将现有 WebSocket 会话均匀分配到新的线程或实例，但不能重复建立连接。以下是具体策略：

#### 使用集中式连接管理

**任务管理中心**（如 Redis 或 Zookeeper）记录所有 WebSocket 连接的归属关系

- 每个 WebSocket 地址与其归属的实例或线程关联。
- 扩容后，新的实例或线程从任务管理中心领取部分任务，并更新任务归属。

流程：

1. 新实例启动后，向任务管理中心发送请求领取任务
2. 任务管理中心基于负载情况，将部分连接重新分配到新实例
3. 旧实例关闭连接时，确保新实例已接管()

#### 动态负载均衡

实现 WebSocket 会话动态迁移：

- 将要迁移的连接从旧实例关闭，由新实例重新建立连接。
- 使用 WebSocket 的唯一标识（如地址）确保连接不会重复创建。

#### 通过协调机制避免重复

利用锁机制（如 Zookeeper 分布式锁）确保每个 WebSocket 地址只有一个实例处理。

- 线程或实例在领取任务时先尝试获取锁，确保唯一性。

### 应用重启：如何准确重建 WebSocket Sessions

当应用重启时，需要重建已断开的 WebSocket 连接，同时避免数据丢失或重复处理。

#### 状态持久化

在 Kafka 消息处理时，将每个 WebSocket 的状态（地址、连接时间、最后处理的消息 ID 等）持久化到数据库或缓存系统（如 Redis）。

- 每次 WebSocket 连接或数据拉取时，更新状态。
- 重启后读取状态进行恢复。

#### 重建流程

1. 恢复任务列表：
   - 应用启动时，从数据库或缓存读取所有未完成的 WebSocket 任务。
2. 按状态重建连接：
    - 检查连接状态（例如，是否仍在有效时间范围内）。
    - 对需要恢复的连接重新建立 WebSocket。
3. 保证幂等性：
    - 使用数据的唯一标识（如消息 ID）和 Kafka 的 offset，确保数据处理不会重复。
    - 只有处理完毕的数据，才会提交 Kafka 的偏移量。

#### 重启过程中避免竞争

使用分布式锁机制（如 Redis 的 SETNX 或 Zookeeper）确保只有一个实例能处理某个 WebSocket 任务

- 例如，在重启后，每个实例尝试领取任务时，通过锁机制避免重复连接

### 整体恢复(*)流程整合

#### 系统启动时

1. 检查任务状态
    - 从持久化存储中加载未完成的 WebSocket 会话任务。
2. 任务分发
    - 通过任务调度中心（如 Redis/Zookeeper）重新分配任务。
3. 恢复连接
    - 任务分配后，实例或线程恢复对应 WebSocket 连接。

#### 系统扩容时

1. 新实例注册：
    - 新实例加入后，向任务管理中心发送请求。
2. 任务重新分配：
    - 调度中心根据负载均衡策略，重新分配部分 WebSocket 连接到新实例。
3. 迁移任务：
    - 旧实例释放连接，新实例建立对应连接。

#### WebSocket 管理中

1. 实时状态更新：
    - 每个 WebSocket 任务的状态定期持久化。
2. 连接健康检查：
    - 定期检查 WebSocket 是否仍然有效，自动重新连接断开的任务
